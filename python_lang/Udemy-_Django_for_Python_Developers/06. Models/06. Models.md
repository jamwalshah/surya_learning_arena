# 06. Models

## 043. Introduction

- The next important component in the `MVT (Model View Template)` architecture is the `Model` component
- `Model` represents the database table and it is through this Model that our view will perform all the database operations
- So, each `Model` in our application will represent a `database table`, and every `Model class` that we create will inherit/extend `django.db.models.Model` class, and they'll have the corresponding fields
- for example, `Employee` model here has `firstName`, `lastName`, `salary`, each of these fields will represent a database table column, so an `Employee` table will have a `firstName`, `lastName` and `salary` columns
- The beauty of Django is that we can create the database structure from our models using commands like `makemigrations`
- The `makemigrations` command when you execute it, will generate the SQL code from your model class by looking at your model class and using that SQL we can create the database tables by using the `migrate` command
- From that point, you can maintain all your database tables through these two commands
  1. `makemigrations`
  2. `migrate`
- So, if you add a new column later on to your `Employee` model, you can execute these commands again, it'll just do the `ALTER` command on the database and data will stay intact
- Along with your application tables, when you migrate, Django also creates many other tables which are required for the administration that is `admin` application that comes with Django, and that application will use the `admin` tables
- There are other tables like `security` table which are useful for authentication and authorization which we'll be using later on and also, when you do session management, Django will have tables for that as well too
  - You store the session information, Django will generate certain special tables
- Along with your application related tables like `Employees`, `Students`, etc., Django will create other tables for free when you execute `makemigrations` and `migrate` commands, and it'll internally use them
- Simply remember that every model that you create will represent a database table and your model class will have all the fields which represent the table columns, and also model can perform various database operations without writing any SQL which we'll learn in the next few lectures

## 044. Hands on Steps

- In the next few lectures, you'll create your very first model called `Employee` with four fields `First Name`, `Last Name`, `Salary` and `Email`
- You'll then create a database table for this `Employee` using the `migrate` tool that Django provides you with
- Here are the steps that you'll follow
  1. Create the project
  2. Configure the database
      - by default Django will use the `sqlite` database
      - and you're going to configure the `MySQL` database for your project
  3. Create the `Employee` model class
  4. Make the migrations
      - `makemigrations` will generate all the SQL code required to create the database tables
      - execute the `migrate` command that will create the database tables
  5. Use the model inside the view, fetch the data from the database using the model in your view and render it on the UI using a template as follows

## 045. Create a project

- In this lecture, you'll create a new project, see its database configuration that comes by default, and also validate that database configuration, that is we'll see if we can connect to that database
- Goto terminal/command-line, make sure you're in the `djangoprojects` directory, create a new project using command below, hit enter and we have a project

```bash
django-admin startproject modelDemo
```

- Go inside the project `modelDemo` using command below

```bash
cd modelDemo
```

- we can create an application `empApp` using command below for an employee, hit enter and we have a new application created

```bash
python manage.py startapp empApp
```

- Now, go back to your file explorer open the `modelDemo` project in your IDE, and open the `settings.py` file, search for 'DATABASES', and there you'll see the databases that have been configured
  - By default, every Django web-application comes with a `sqlite` database for free, and as you can see it is located directly under the `BASE_DIR` of your project

  ```python
  DATABASES = {
      'default': {
          'ENGINE': 'django.db.backends.sqlite3',
          'NAME': BASE_DIR / 'db.sqlite3',
      }
  }
  ```

  - Right under your project directory, there will be a sqlite database and we can right away use it, create models, do the migrations, and when you migrate all the tables will be created inside `db.sqlite3` database
  - This `sqlite` is very good for testing and to work locally, but in real-time applications, when we deploy it om testing or production environments, we won't be using it, instead we use MySQL, Oracle, etc.
  - If you want to validate that if your application can connect to this database, `ENGINE` and `NAME` is that part which shows database connection information, sqlite doesn't need much information to connect, all it needs is `ENGINE` and the name of the database 'db.sqlite3' which is indicated by `NAME` key
  - But, MySQL, Oracle databases will need more information like the username, password, etc. which we'll learn in the next lecture
  - To validate if your application can connect to this application, goto terminal/command-line, make sure you're under the project directory `djangoprojects/modelDemo` and open up a special shell using below command and it'll open up a shell for you where you can use Django packages here

  ```bash
  python manage.py shell
  ```

  - Now, in this new python shell, run below code/command to import the `connection` from `django.db` package

  ```python
  from django.db import connection
  ```

  - Now, run below code/command, if you're able to create this cursor successfully that means your application can connect to the database and our database configuration information is correct

  ```python
  c = connection.cursor()
  ```

  - To come out of this shell hit `Ctrl+D` or type command `exit`
  - by default, under the project directory, there is a `db.sqlite3` that is a database which is okay for development but we're not going to use it
  - At some point, instructor will show you how to use it, but we're going to use MySQL, which you'll configure in the next lecture

## 046. Using MySQL Database

- In this lecture, we'll see how to configure MySQL database for our application and project
- We can do that using the following configurations/properties in the `settings.py` file
  1. `ENGINE`
      - the engine name
  2. `NAME`
      - the name of the database itself
  3. `USER`
      - the user to connect to the database
  4. `PASSWORD`
      - the password that we should use for that user
  5. `HOST`
      - a hostname is it is running on a remote machine or a server
  6. `PORT`
      - the port number
- If we don't provide some of these fields such as `HOST` and `PORT` it'll consider the local machine as the host and default port number on which that database runs
- Lets configure MySQL database, and for this MySQL database server should be up and running
- Also, launch your MySQL workbench which is a MySQL client tool
  - Goto a new SQL window by clicking on `+` icon on the left-corner of your screen
- Once you have that, go back to your IDE, and open the `settings.py` file snd goto `DATABASES` configuration in it
  - for MySQL the very simple change here is that `django.db.backends.sqlite3` will become `django.db.backends.mysql` for the value of `ENGINE` , and provide the name of the MySQL database in `NAME`
  - Now, goto MySQL Workbench, and run below command to create a MySQL database `employeedb12`

  ```SQL
  CREATE DATABASE employeedb12;
  ```

  - Now you can configure the `NAME` in `DATABASES` property in `settings.py` using the database name which you just created
  - The next property is `USER`, when you install MySQL you have a 'root' user which is exactly what you should be using here
  - And, the password for the 'root' user needs to be provided using the `PASSWORD` field, what ever password you have provided while installing MySQL initially, you should be using that here
  - You need not provide the `HOST` and `PORT`, it'll use the default hostname and port number
  - If you're running it on a remote machine or a server, you can use the `HOST` and `PORT` as well

  ```python
  DATABASES = {
      'default': {
          'ENGINE': 'django.db.backends.mysql',
          'NAME': 'employeedb12',
          'USER': 'root',
          'PASSWORD': 'mysql',
      }
  }
  ```

  - To validate these `DATABASES` property, go to command-line/terminal, if you already have python shell for project open, you can use it, and if not use command below to launch a python shell for project

  ``` bash
  python manage.py shell
  ```

  - Now, import the `connection` from `django.db`

    ```python
    from django.db import connection
    ```

  - Now, create a `cursor()` object from `connection`, after running below command

    ``` python
    c = connection.cursor()
    ```

  - if you don't see any error, it means it is able to connect to MySQL database, because it'll use the set configuration from `DATABASES` property in `settings.py` file to connect to whatever database we specify
- So, in this lecture you've successfully configured a MySQL database by creating a new database `employeedb12`

## 047. Create the model

- The next step is to create a Model class called `Employee`
- Goto your IDE, we create the Model class inside `models.py` file, so go inside `empApp` application directory and open the `models.py` file
  - You already have an import statement indicated below to import `models`, and from this `models` we use class `Models` that our model will inherit

  ```python
  from django.db import models
  ```

  - Create a class `Employee` which extends `models.Model`, so every model class will be inherited from `models.Model` class
  - Now you can specify all the fields you have inside this class
    - You need to specify what type of each field is and you can also specify any kind of restrictions you want here such as `max_length=30`
    - `models` package gives us the ability to do all this, which is to specify what type of a field is and to specify its restrictions like `NOT NULL` etc.
    - By default, all the fields on model are `NOT NULL` in the database and when the database gets generated from this you'll see that they're `NOT NULL` fields
  - Create four fields in this class
    - `firstName` as `CharField` with `max_length=30`
    - `lastName` as `CharField` with `max_length=30`
    - `salary` as `FloatField`
    - `email` as `CharField` with `max_length=35`
  
  ```python
  class Employee(models.Model):
    firstName = models.CharField(max_length=30)
    lastName = models.CharField(max_length=30)
    salary = models.FloatField()
    email = models.CharField(max_length=35)
  ```

- In this lecture, you've successfully created your very first Model class by going to `models.py`, you've used `models.Model` class that your model should extend and within your class you've defined all the fields that this model should contain
- When we generate database tables from this model these four columns on the table along with the `id` column that `Django` adds to every table

## 048. Converting Model to DB tables

- In this lecture we'll generate the database code that us responsible for creating all the tables for us from this model
- But, first we need to take an additional step, goto `settings.py`, search for `INSTALLED_APPS`, and we need to add our app `empApp` in this property which we missed right when we created this app, so now our application will be a part of our project

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'empApp',
]
```

- To create tables, goto terminal.command-line, make sure you're under the project directory
- To make migrations we use command below, and if you hit enter it'll generate the database code from the Model class

```bash
python manage.py makemigrations
```

- After you run this command it says Migrations for `empApp` are created under `empApp/migrations/001_initial.py`
- You can view this `0001_initial.py` file by going to your IDE, open folder `migrations` inside `empApp` application folder, and open the `0001_initial.py` file, and this file contains only the python part
- If you want to get the SQL that will be generated out of it, goto terminal/command-line and run below command, we don't use this command every time but if you want to see what kind of SQL it generates, when you hit enter it shows you the exact SQL it will use to create the table for us

```bash
python manage.py sqlmigrate <AppName> <prefix Number of initial.py>
```

```bash
python manage.py sqlmigrate empApp 0001
```

```SQL
--
-- Create model Employee
--
CREATE TABLE `empapp_employee` (`id` bigint AUTO_INCREMENT NOT NULL PRIMARY KEY, `firstName` varchar(30) NOT NULL, `lastName` varchar(30) NOT NULL, `salary` double precision NOT NULL, `email` varchar(35) NOT NULL);
```

- Here, `id` field is added automatically as an `AUTO_INCREMENT`, so it'll be incremented automatically and we need not increment it each time manually
  - Note that `firstName`, `lastName` and `email` fields are created as `VARCHAR` with the specified length, `salary` is `DOUBLE` type and all the fields are `NOT NULL` by default
  - If you want to make a field as `NULL`, you need to add a property to the field in model as `null=True`
- It has not created the table yet
- Every time you do `makemigrations` it'll generate a new file with different prefix of `initial.py`
- To Migrate, goto command-line/terminal, run command below and it'll execute all the command that we need, it creates Django tables and also `empApp` app tables

```bash
python manage.py migrate
```

- Now, you can goto MySQL workbench, run commands to see all the tables which Django has created from migrations

```SQL
USE employeedb12;
SHOW TABLES;
```

- Django will create all these admin & security related tables and at the end we care about for now is the `empApp_employee`
- run below command in MySQL workbench and we'll see all the fields from models and `id` field

```SQL
SELECT * FROM empApp_employee;
```

- In this lecture, you've successfully made the migrations which will generate SQL code, and then you've performed a migrate and execute the SQL, so as a result we got all the tables in the database, and also our custom table which we have created

## 049. Use the model in view

- In this lecture, we'll use the Model inside the view
- For that we need to create a view for our application, goto your IDE, open `views.py` file in `empApp` application directory
  - The very first step is to create a view `employeedata(request)` which takes a `request` and retrieves a list of employees
  - `ModelClass.objects.all()` or `Employee.objects.all()` will give us all the Employee objects, so it'll execute an SQL query `SELECT * FROM empApp_employee` and it'll return all the records for us as an object
  - Now create a dictionary for the returned list as `empDict` which is what we'll return from this view as its response

  ```python
  from empApp.models import Employee
  # Create your views here.
  def employeedata(request):
      employees = Employee.objects.all()
      empDict = {'employees':employees}
      return render(request=request, template_name='employees.html', context=empDict)
  ```

  - Here, we've provided a template `employees.html` which we need to create in the next lecture
- So, in this lecture, we have created a view which uses the `Employee` model to retrieve all the employees in the database, then we're assigning that list inside a dictionary, because the render method expects a dictionary object for which key is 'employees' and the value is the list of employees that comes back and we're rendering it to a template which we'll create in the next lecture
- This template `
employees.html` takes this dictionary `empDict` and creates a nice HTML table for us

## 050. Create the template

- In this lecture, we'll create our template which is `employees.html`
- To do that, we'll have to configure the templates directory in the `settings.py` file, so goto `settings.py` file, and search for `TEMPLATES` property
  - Here, we need to configure the `DIRS` in `TEMPLATES` property by adding the `templates` directory

  ```python
  TEMPLATES = [
      {
          'BACKEND': 'django.template.backends.django.DjangoTemplates',
          'DIRS': [os.path.join(BASE_DIR, 'templates')],
          'APP_DIRS': True,
          'OPTIONS': {
              'context_processors': [
                  'django.template.context_processors.debug',
                  'django.template.context_processors.request',
                  'django.contrib.auth.context_processors.auth',
                  'django.contrib.messages.context_processors.messages',
              ],
          },
      },
  ]
  ```

- Now, we need to create a folder named `templates` under our project directory, and within the `templates` folder we'll create a new file named `employees.html`, and within the `body` we'going to create an HTML table
  - Add a `title` as 'Employee Information'
  - within the `body`, add a heading `h1` as 'Employee List:'
  - The first step here is we're going to use the template tags, and within these template tags we're doing an `{% if employees %}` check for `employees` which we're sending from the view as a list inside a dictionary and we're checking if this list is NOT NULL, it contains some elements only then it'll create an HTML table
  - Add a `thead` to add the table headings and inside it use `th` tag to add table heading column names as `First Name`, `Last Name`, `Salary` and `Email`
  - Next, to display the actual data itself we'll have to use a `for` loop, and for that we'll use template tags again `{% for emp in employees %}`
  - add table row `tr` and within it add table data `td` using another template variable `{{ emp.firstName }}` in the syntax `{{ object.modelField }}`
  - Now add table data `td` for other fields such as `lastName`, `salary` and `email` to access the template variables
  - Outside the ending of table row `tr`, add another template tag `{% endfor %}` to close the `for` loop
  - Now after `table` tag, add template tag `{{ else }}` to display a message `No records found.` in `p` paragraph tag
  - we've to end the template tag of `{% if employees %}` using another template tag `{% endif %}`
- In this lecture, you've successfully created a `template` within which we're taking the data that `view` sends and it is rendered using a for loop creating multiple rows, one for each employee

## 051. Run and Test

- In this lecture, we'll see our MVT application, the complete Model, View and Template in actions
- Goto `urls.py` and quickly configure a URL for your View
  - import `views` from `empApp` application

    ```python
    from empApp import views
    ```

  - in `urlpatterns` add another `path()` with route `emps/`, and view as `views.employeedata`

    ```python
      urlpatterns = [
        path('admin/', admin.site.urls),
        path('emps/', views.employeedata),
    ]
    ```

- Now, goto terminal/command-line, make sure, you're in the project directory, and start the Django server using the below command

  ```bash
  python manage.py runserver
  ```

- Now, Launch your web-browser, and visit `localhost:8000/emps`, and there we can see our application as complete MVT as expected
  - There are no records in the database, and we're going to create forms, etc. in the next section where we'll oerfom all the CRUD operations
- For now, Lets pull some data from the database by loading data or inserting records
  - Goto MySQL Workbench and run command, and now we have a record in the database

  ```SQL
  INSERT INTO empApp_employee VALUES (1, 'Surya', 'Dev Singh Jamwal', 100000, 'a@b.com');
  ```

  - If you do a a `SELECT` query, you'll see the recently inserted record

  ```SQL
  INSERT INTO empApp_employee VALUES (1, 'Surya', 'Dev Singh Jamwal', 100000, 'a@b.com');
  ```

  > When we do CRUD operations from the application itself, the `id` field need not be provided, it'll be automatically incremented for us
- Now, goto the web-browser, and refresh/visit the page at `localhost:8000/emps`, and it loads the data, so our MVT application is working successfully

> When a request comes in, the `view` takes the request, it uses the `model` and fetches all the data, it loads the data into a dictionary object and it returns it to the `template` that should render it, then the `template` takes the data and it uses the loops from Django tamplate tags to create an HTML table

## 052. Django Admin UI

- When you've configured the URLs for the very first time in the very first section of this course, instructor told that he'll explain about the `admin` URL later on, which is exactly what instructor will do now
- Django by default provides an Admin interface/Admin UI for every web-application we create and that is the URL which is being used here in the `admin/` route in `urlpatterns` list in `urls.py` file
  - in the `path()` call in `urlpatterns` list in `urls.py` file, we have route as `admin/` and view as `admin.site.urls` which points to a default administration application provided by Django
- Make sure your Django application server is up-and-running, goto the web-browser and access your application at `localhost:8000` and you'll see a secret here
  - It says `Page not found (404)`, but Django also shows you all the URLs that are available within that project, `admin/` is the one and `emps/` is the another URL
  - If you access `emps/` URL at `localhost:8000/emps`, it is no surprise which you already know, the output here is coming from our Model, view and template which we've created
  - But there is another URL `admin/` , visit it at `localhost:8000/admin` and see what happens, the UI which you see at this URL is generated by the Djngo on-the-fly
    - the package `django.contrib.admin` is responsible for all this
- To login to this UI, you need to create a super-user, you do that by going to the terminal/command-line, you can either stop the running Django server or launch another terminal/command-line, and run the command

```bash
python manage.py createsuperuser
```

- When you run this command
  - it'll ask for the username, by default it'll take the system username that you have, but I don't want to use it, I want `admin` as the username, then hit enter
  - next, it'll ask for email address, you can skip it by hitting enter
  - then, it'll ask for password, use `admin` as password here and hit enter
  - Enter password again as `admin` and hit enter
  - then it'll ask if you want to keep that password as it has a password policy, type `y` and hit enter to create the super user
  - Now, your super-user is created successfully
- Now start the Django server using command

```bash
python manage.py runserver
```

- Now go back to the web-browser, open the admin panel by visiting `localhost:8000/admin` and login using username as `admin` and password as `admin`, and we see a beautiful UI here
  - You can configure `Users` for your application when we goto into security, these will come into effect
  - We can also create `Groups`, so that we can authorize those `Users` by assigning them to a particular group
- In the next few lectures, instructor will show you how you can use this admin UI to view the objects or the Model, the data that is available in the database can be viewed on this screen without much work, we can add the Model to the administrative screen by registering the models in the `admin.py` file
- Also, we can do updates to the databse using this admin UI on-the-fly

## 053. Adding Model to the Admin UI

- In this lecture, you'll learn how to add our Model which is `Employee(models.Model)` to the Admin UI, that Django generates
- To do that, goto, `admin.py` in our app `empApp`, notice the comment that says below text, which is exactly we're going to do

```python
from django.contrib import admin
# Register your models here.
```

- Now register the site using `register(Employee)` function from `django.contrib.admin.site.register()` that takes a class `Employee`, and we need to impor this `Employee` class from `empApp.models.EMployee`

```python
from django.contrib import admin
from empApp.models import Employee
# Register your models here.
admin.site.register(model_or_iterable=Employee)
```

- Now, if you go back to the Admin UI in web-browser, and refresh it, it displays the `empApp`, and under it you can see the `Employees` which is the object
- Click on the `Employees` object, it'll take you to a screen where you can perform CRUD operations on the object
  - Notice that it shows only one action/operation `Delete` which is available now for the first row in the database, so you're seeing the `Employee` object here
  - You can make this UI look better, which will be explained in next lecture
  - For now, You can delete this object or if you click on this object it will take you to a screen where you can perform `Delete`, `Update` and much more
  - Lets Change the First Name , and then click on `Save and add another`, so it saves the object and updates that to the database
  - Now goto the MySQL database Wokbench, do a `SELECT` query using below query, and you'll see that the first name got updated

  ```SQL
  SELECT * FROM empApp_employee;
  ```

  - Now, go back to the web-browser, there you can enter a new employee with FirstName as `Sarath`, LastName as `T`, Salary as `5000` and Email as `test@test.com`, and then hit `Save` button, so it has two objects now
  - Now, goto MySQL Workbench, run a `SELECT` query using below query, and you'll see two records

  ```SQL
  SELECT * FROM empApp_employee;
  ```

## 054. Displaying Model fields on the UI

- In the previous lecture, you've learnt how to add our Model to the Admin UI and even performed CRUD operations
- When we click on the `Employees` model, you see the records as objects instead of showing all the fields on each of them like columns in the table, it says `Employee object (1)` and `Employee object (2)`, and when you click on them you can perform CRUD operations
- But, if you want to, make this UI even better, you can do that in very simple steps
- Go back to the `admin.py` file, here we can create a class `EmployeeAdmin(admin.ModelAdmin)` which extends to `admin.ModelAdmin`, and within this class, all we have to do is to provide a list `list_display` containing all the fields you want to expose out from the model `Employee`, for now provide `firstName` and `lastName`, we also need to register this model class `EmployeeAdmin(admin.ModelAdmin)` using `admin.site.register(Employee, EmployeeAdmin)` function

  ```python
  from django.contrib import admin
  from empApp.models import Employee
  # Register your models here.
  class EmployeeAdmin(admin.ModelAdmin):
      list_display = ['firstName', 'lastName']
  admin.site.register(Employee, EmployeeAdmin)
  ```

- So, we're telling the admin site that we're providing you a `ModelAdmin` for the `EmployeeAdmin` class, and within that class you're providing a list that it has to display
- Note that, the list name should be `list_display` because Django uses that convention, and inside it you provide a list of fields from the `models.py` file that you want to expose out
- Now goto web-browser, goto App level `empApp`, open the model `Employees`, now you don't see any objects anymore, you'see `firstName` and `lastName` which makes the view better
- You can expose out more fields if you want to
- Go back to `admin.py` file, in `list_display` list, add more fields `salary` as well, save it and go back to `Employees` model in web-browser, refresh it, it'll display the `salary` fields too

  ```python
  from django.contrib import admin
  from empApp.models import Employee
  # Register your models here.
  class EmployeeAdmin(admin.ModelAdmin):
      list_display = ['firstName', 'lastName', 'salary']
  admin.site.register(model_or_iterable=Employee, admin_class=EmployeeAdmin)
  ```

- So, everything happens on-the-fly, Django wil; pick up the list `list_display` to display, it fetches the data from the database and then renders on the UI

## 055. Using SqlLite DB

- asa
